# EifMate

**Claude-to-EiffelStudio Bridge: Enabling AI-Assisted Eiffel Development**

[![Status](https://img.shields.io/badge/status-Phase%200%20POC-yellow)](https://github.com/ljr1981/eifmate)
[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
[![EiffelStudio](https://img.shields.io/badge/EiffelStudio-25.02-green)](https://www.eiffel.com/eiffelstudio/)

EifMate is a command-line bridge that enables Claude AI (via MCP - Model Context Protocol) to compile, query, and test Eiffel projects using EiffelStudio. It provides a structured JSON API for seamless AI-to-compiler communication, transforming AI-assisted Eiffel development from theoretical to practical.

---

## ğŸ¯ Vision & Purpose

### The Problem
AI assistants like Claude can generate Eiffel code, but they operate in a feedback vacuumâ€”no way to know if the code compiles, what errors occurred, or how to iterate toward working solutions.

### The Solution
EifMate bridges this gap by providing:
- âœ… **Compile Eiffel projects** via `ec.exe` with structured error reporting
- âœ… **Query class interfaces** using EiffelStudio's code analysis tools
- âœ… **Parse ECMA-367 error codes** with helpful explanations
- âœ… **JSON request/response protocol** for seamless AI integration
- ğŸš§ **AutoTest integration** for comprehensive testing feedback
- ğŸš§ **Retry/rollback mechanisms** for safe iterative development

### Real-World Impact
Built from Larry Rix's proven experience: **44-66x productivity gains** using AI-assisted development with SIMPLE_JSON library (11,404 lines in 4 days). EifMate aims to replicate and scale these results across all Eiffel projects.

---

## ğŸ—ï¸ Architecture

```

Claude AI (MCP Client)
â†“ JSON Request
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   EM\_CLI\_APP        â”‚  â† CLI Entry Point
â”‚   (eifmate\_cli.exe) â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Core Processing Pipeline                  â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  EM\_REQUEST      Parse JSON requests       â”‚
â”‚  EM\_CLI          Orchestrate operations    â”‚
â”‚  EM\_COMPILER     Execute ec.exe commands   â”‚
â”‚  EM\_PROJECT      ECF configuration         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Error Intelligence                        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  EM\_ERROR\_PARSER       Parse compiler msgs â”‚
â”‚  EM\_VALIDITY\_CATALOG   ECMA-367 lookup     â”‚
â”‚  EM\_ERROR              Structured errors   â”‚
â”‚  EM\_ERROR\_LOCATION     File/line context   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â†“
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  EM\_RESPONSE     Build JSON output         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
â†“
JSON Response to Claude

````

---

## ğŸ“¦ Current Status

**Phase:** Phase 0 - Proof of Concept (POC) ğŸ”„  
**Development Model:** Dogfooding from Day 1  
**Compilation:** Clean compile âœ…  
**Tests:** Infrastructure in place âœ…

### âœ… Completed (Phase 0)

#### Core Infrastructure
- [x] [cite_start]Project structure with proper ECF configuration [cite: 12]
- [x] [cite_start]Multiple targets: library, CLI, tests, future GUI/daemon/server [cite: 12]
- [x] Thread concurrency support for PROCESS library
- [x] SIMPLE_JSON integration for request/response handling
- [x] Comprehensive .gitignore for Eiffel projects

#### Core Classes (Implemented)
- [x] `EM_CLI_APP` - CLI entry point with argument handling
- [x] `EM_CLI` - Request orchestration and processing
- [x] `EM_REQUEST` - JSON request parsing
- [x] [cite_start]`EM_RESPONSE` - JSON response building with robust contracts and timestamps [cite: 1, 9]
- [x] [cite_start]`EM_COMPILER` - EiffelStudio compiler wrapper with stateless tuple support [cite: 65]
- [x] `EM_PROJECT` - ECF project representation
- [x] `EM_CONSTANTS` - Project-wide named constants

#### Error Intelligence System
- [x] `EM_ERROR` - Structured error representation
- [x] `EM_ERROR_LOCATION` - File/line/column tracking
- [x] [cite_start]`EM_ERROR_PARSER` - State machine parsing for multi-line compiler output [cite: 14]
- [x] `EM_VALIDITY_CODE` - ECMA-367 error code model
- [x] `EM_VALIDITY_CATEGORY` - Error categorization
- [x] `EM_VALIDITY_CATALOG` - Error code catalog with explanations

#### Testing Infrastructure
- [x] `TEST_SET_BASE` - Base test class with shared assertions
- [x] [cite_start]`TEST_EM_COMPILER` - Coverage for melt, quick_melt, flat view, and configuration [cite: 22]
- [x] AutoTest framework integration
- [x] Example test demonstrating patterns

#### Documentation
- [x] JSON request/response examples
- [x] Usage patterns and examples
- [x] Design pattern documentation

### ğŸš§ In Progress

- [ ] ECMA-367 validity codes JSON catalog population
- [ ] JSON response generation integration test
- [ ] End-to-end POC validation

### ğŸ“‹ Planned (Phase 1+)

- [ ] AutoTest integration for test execution
- [ ] Multiple compilation modes (compile/freeze/finalize)
- [ ] Query operations (flat, flatshort, descendants, etc.)
- [ ] Snapshot/restore for safe iteration
- [ ] Retry logic with automatic rollback
- [ ] Timeout handling
- [ ] Watch mode for continuous compilation
- [ ] MCP protocol server integration
- [ ] Optional GUI monitor (Phase 6-7)

---

## ğŸš€ Quick Start

### Prerequisites

- **EiffelStudio 25.02** or later (required)
- **Eiffel PROCESS library** (included with EiffelStudio)
- **SIMPLE_JSON library** ([ljr1981/simple_json](https://github.com/ljr1981/simple_json))
- **Windows** (for `ec.exe` - Unix support planned)

### Building

1. **Clone the repository:**
```bash
git clone [https://github.com/ljr1981/eifmate.git](https://github.com/ljr1981/eifmate.git)
cd eifmate
````

2.  **Open in EiffelStudio:**

<!-- end list -->

```bash
# Option 1: Double-click eifmate.ecf in Windows Explorer
# Option 2: Use EiffelStudio command line
estudio eifmate.ecf
```

3.  **Select target and compile:**

      - **For development:** Select target `eifmate_tests`
      - **For CLI executable:** Select target `eifmate_cli`
      - **Compile:** Press F7 or click the Compile button

4.  **Run tests:**

      - Ensure target `eifmate_tests` is selected
      - Navigate to: **Testing \> AutoTest**
      - Click: **Execute All Tests**

-----

## ğŸ“‚ Project Structure

```
eifmate/
â”œâ”€â”€ eifmate.ecf                    # Project configuration
â”œâ”€â”€ README.md                      # This file
â”œâ”€â”€ .gitignore                     # Git exclusions
â”‚
â”œâ”€â”€ examples/                      # Example JSON files
â”‚   â”œâ”€â”€ example_request_compile.json
â”‚   â”œâ”€â”€ example_request_query.json
â”‚   â””â”€â”€ example_response.json
â”‚
â”œâ”€â”€ src/
â”‚   â””â”€â”€ cli/                       # All implementation (Phase 0)
â”‚       â”œâ”€â”€ em_cli_app.e          # CLI entry point
â”‚       â”‚
â”‚       â”œâ”€â”€ core/                  # Core processing
â”‚       â”‚   â”œâ”€â”€ em_cli.e          # Request orchestration
â”‚       â”‚   â”œâ”€â”€ em_compiler.e     # Compiler wrapper
â”‚       â”‚   â”œâ”€â”€ em_constants.e    # Named constants
â”‚       â”‚   â”œâ”€â”€ em_project.e      # ECF representation
â”‚       â”‚   â”œâ”€â”€ em_request.e      # JSON request parser
â”‚       â”‚   â””â”€â”€ em_response.e     # JSON response builder
â”‚       â”‚
â”‚       â”œâ”€â”€ error/                 # Error intelligence
â”‚       â”‚   â”œâ”€â”€ em_error.e                # Error model
â”‚       â”‚   â”œâ”€â”€ em_error_location.e       # Location tracking
â”‚       â”‚   â”œâ”€â”€ em_error_parser.e         # Output parsing
â”‚       â”‚   â”œâ”€â”€ em_validity_code.e        # ECMA-367 codes
â”‚       â”‚   â”œâ”€â”€ em_validity_category.e    # Error categories
â”‚       â”‚   â””â”€â”€ em_validity_catalog.e     # Code catalog
â”‚       â”‚
â”‚       â””â”€â”€ validity/              # ECMA-367 catalog
â”‚           â””â”€â”€ em_validity_json.e        # JSON catalog loader
â”‚
â””â”€â”€ testing/
    â”œâ”€â”€ application.e              # Test application root
    â”œâ”€â”€ test_set_base.e            # Base test class
    â””â”€â”€ cli/
        â”œâ”€â”€ test_em_compiler.e     # Compiler wrapper tests
        â””â”€â”€ test_em_in_system.e    # System integration test
```

-----

## ğŸ”§ Usage

### JSON Request/Response Protocol

EifMate communicates via structured JSON for maximum clarity and type safety.

#### Compile Request

```json
{
  "type": "compile",
  "ecf_path": "D:/projects/myapp/myapp.ecf",
  "target": "myapp_cli"
}
```

#### Query Request

```json
{
  "type": "query",
  "query_type": "flatshort",
  "ecf_path": "D:/projects/myapp/myapp.ecf",
  "target": "myapp_cli",
  "class_name": "MY_CLASS"
}
```

#### Response Format

```json
{
  "success": false,
  "output": "Degree 6: Examining System\nDegree 5: Parsing Classes\n...",
  "errors": [
    {
      "code": "VUTA(2)",
      "message": "Error code: VUTA(2)\nWhat to do: check whether...",
      "severity": "error",
      "class": "MY_CLASS",
      "feature": "make",
      "line": 42,
      "file": "D:/projects/myapp/src/my_class.e",
      "suggestion": "check whether feature name is spelled correctly..."
    }
  ],
  "warnings": [],
  "timestamp": "2024-11-16T12:34:56Z"
}
```

### Command Line Interface

```bash
# Read JSON from stdin (default mode)
echo '{"type":"compile",...}' | eifmate_cli.exe

# Read from JSON file
eifmate_cli.exe --json request.json

# Direct command-line compilation
eifmate_cli.exe compile D:/projects/myapp/myapp.ecf myapp_cli

# Query class interface
eifmate_cli.exe query flatshort D:/projects/myapp/myapp.ecf myapp_cli MY_CLASS

# Display help
eifmate_cli.exe --help
```

-----

## ğŸ¯ Design Patterns & Best Practices

### Design by Contract

All features use comprehensive contracts with named assertions:

```eiffel
make_from_json (a_json: STRING)
    require
        json_attached: a_json /= Void
        not_empty: not a_json.is_empty
    do
        -- Implementation
    ensure
        valid_if_parsed: is_valid implies (attached project_path)
    end
```

### Feature Organization

Classes follow standard Eiffel categories:

  - `{NONE} -- Initialization` - Private creation procedures
  - `Access` - Query features returning values
  - `Status report` - Boolean state queries
  - `Element change` - Modification commands
  - `Conversion` - Type conversions
  - `{NONE} -- Implementation` - Private helpers
  - `{NONE} -- Constants` - Named constants

### Named Constants Pattern

All magic values replaced with semantic constants:

```eiffel
class EM_CONSTANTS
feature -- Validity codes
    Vuta_2_code: STRING = "VUTA(2)"
        -- Feature name not found in class
        
    Default_timeout_seconds: INTEGER = 300
        -- Default compilation timeout (5 minutes)
end
```

### Multiple Creation Procedures

Descriptive creators for clarity:

```eiffel
create
    make,
    make_with_path,
    make_with_path_and_target,
    make_from_json
```

### Error Intelligence

ECMA-367 error catalog provides helpful explanations:

```eiffel
class EM_VALIDITY_CODE
    -- Maps ECMA-367 validity codes to explanations
    -- Example: VUTA(2) -> "Feature name not found"
end
```

-----

## ğŸ§ª Testing

### Test Framework

EifMate uses EiffelStudio's AutoTest framework with custom base class:

```eiffel
class TEST_MY_FEATURE
inherit
    TEST_SET_BASE
        -- Provides assert, assert_32, and other helpers

feature -- Tests
    test_compilation_success
        note
            testing: "covers/{EM_COMPILER}.compile"
        local
            l_compiler: EM_COMPILER
            l_result: BOOLEAN
        do
            create l_compiler.make
            l_result := l_compiler.compile (test_ecf_path, "test_target")
            assert ("compilation_succeeded", l_result)
        end
end
```

### Running Tests

1.  Open `eifmate.ecf` with target `eifmate_tests`
2.  Navigate to: **Testing \> AutoTest**
3.  Click: **Execute All Tests**

### Test Organization

```
testing/
â”œâ”€â”€ application.e              # Test root class
â”œâ”€â”€ test_set_base.e            # Base class with shared utilities
â””â”€â”€ cli/
    â””â”€â”€ test_em_in_system.e    # Brings all EM_* into system
```

-----

## ğŸ› ï¸ Dependencies

### Required Libraries

| Library | Purpose | Source |
|---------|---------|--------|
| **base** | Core Eiffel (EiffelBase) | EiffelStudio |
| **process** | Subprocess execution | EiffelStudio |
| **simple\_json** | JSON parsing/generation | [GitHub](https://github.com/ljr1981/simple_json) |
| **time** | Timestamp operations | EiffelStudio |
| **encoding** | Text encoding | EiffelStudio |

### Optional Libraries (Future Features)

| Library | Purpose | Status |
|---------|---------|--------|
| **curl** | HTTP client | ğŸ”® Phase 2B |
| **store** | Database operations | ğŸ”® Future |
| **zlib** | Compression | ğŸ”® Future |
| **uuid** | Unique identifiers | ğŸ”® Future |

-----

## ğŸ“‹ ECF Targets

| Target | Purpose | Status | Executable |
|--------|---------|--------|-----------|
| `eifmate` | Base library | âœ… Compiling | No |
| `eifmate_tests` | Test suite | âœ… Compiling | Yes (tests) |
| `eifmate_cli` | CLI tool | âœ… Compiling | Yes (main) |
| `eifmate_gui` | GUI monitor | ğŸ”® Phase 6-7 | Future |
| `eifmate_daemon` | Watch service | ğŸ”® Phase 3 | Future |
| `eifmate_server` | HTTP server | ğŸ”® Phase 2B | Future |
| `eifmate_broken` | Negative Testing | âœ… Compiling | Yes |

-----

## ğŸ—ºï¸ Roadmap

### Phase 0: Proof of Concept (Current)

**Goal:** Validate end-to-end compilation cycle  
**Timeline:** 8-12 hours of focused work  
**Status:** ğŸŸ¡ In Progress (85% complete)

**Remaining Work:**

  - [ ] Populate ECMA-367 validity codes catalog
  - [ ] End-to-end test with real Eiffel project
  - [ ] Validate JSON response generation

### Phase 1: Minimal CLI Bridge (Next)

**Goal:** Ship working CLI tool for manual use  
**Timeline:** 4-8 hours  
**Deliverable:** `eifmate_cli.exe` you can run today

**Features:**

  - Single compile request/response
  - Basic error parsing with ECMA help
  - JSON and command-line interfaces
  - Manual iteration workflow

### Phase 2: Testing Integration

**Goal:** Add AutoTest support  
**Timeline:** 3-6 hours  
**Deliverable:** Compile + test in one request

**Features:**

  - Execute AutoTest suites
  - Parse test results
  - Test filtering
  - Combined compile+test workflow

### Phase 3: Snapshots & Retry

**Goal:** Safe iterative development  
**Timeline:** 4-8 hours  
**Deliverable:** Automatic rollback on failure

**Features:**

  - File snapshot/restore
  - Retry logic with max attempts
  - Automatic rollback on failure
  - State management

### Phase 4-5: Dogfooding (2-3 weeks)

**Goal:** Build real libraries with EifMate  
**Projects:**

  - SIMPLE\_SQL library
  - EIFFEL\_KNOWLEDGE library
  - EIFFEL\_SYNTAX library

**Purpose:** Discover pain points through real usage

### Phase 6-7: Optional GUI (Maybe)

**Goal:** Visual monitoring if CLI inadequate  
**Timeline:** 12-20 hours  
**Decision:** Based on Phase 5 dogfooding feedback

-----

## ğŸ¤ Contributing

Contributions are welcome\! Please:

1.  **Fork** the repository
2.  **Create** a feature branch (`git checkout -b feature/amazing-feature`)
3.  **Follow** Eiffel coding conventions (see below)
4.  **Add** tests for new functionality
5.  **Ensure** all tests pass
6.  **Commit** with clear messages (`git commit -m 'Add amazing feature'`)
7.  **Push** to your branch (`git push origin feature/amazing-feature`)
8.  **Open** a Pull Request

### Eiffel Coding Conventions

**Naming:**

  - Locals: `l_` prefix (e.g., `l_result`, `l_count`)
  - Attached locals: `al_` prefix (e.g., `al_value`)
  - Loop cursors: `ic` or `ic_` prefix
  - Constants: `Capitalized_with_underscores`

**Structure:**

  - Note clauses at beginning and end
  - Standard feature categories (see Design Patterns)
  - All assertions named
  - Design by Contract enforced

**Quality:**

  - 100% test coverage goal
  - Clean compile (no warnings)
  - Comprehensive documentation

-----

## ğŸ“ Known Limitations

### Platform Support

  - **Windows:** Full support âœ…
  - **Linux/Mac:** Planned for Phase 2 ğŸ”®

### EiffelStudio Integration

  - **Command-line only:** No GUI integration yet
  - **Single instance:** No concurrent compilations
  - **File locking:** Be aware of EiffelStudio GUI file locks

### Error Parsing

  - **Best effort:** Complex error formats may not parse perfectly
  - **ECMA-367:** Catalog still being populated
  - **Warnings:** Currently treated same as errors

-----

## ğŸ› Known Issues

1.  **File Locking:** EiffelStudio GUI can lock project files

      - **Workaround:** Close project in GUI before using CLI
      - **Status:** Design limitation, not a bug

2.  **Thread vs SCOOP:** ECF must specify `<concurrency use="thread"/>`

      - **Reason:** PROCESS library requires thread concurrency
      - **Status:** Fixed in current ECF

3.  **Windows Paths:** Backslashes in paths need proper escaping

      - **Workaround:** Use forward slashes or double backslashes
      - **Status:** Platform-specific, working as designed

-----

## ğŸ“š Documentation

### Core Documentation

  - [README.md](README.md) - This file (overview)
  - [CRITICAL\_PRINCIPLES.md](https://www.google.com/search?q=/mnt/project/CRITICAL_PRINCIPLES.md) - Design principles
  - [EIFFEL\_PRODUCTION\_GUIDE.md](https://www.google.com/search?q=/mnt/project/EIFFEL_PRODUCTION_GUIDE.md) - Coding patterns
  - [SIMPLE\_JSON\_REFERENCE.md](https://www.google.com/search?q=/mnt/project/SIMPLE_JSON_REFERENCE.md) - JSON library usage
  - [Project\_Plan\_v6.md](https://www.google.com/search?q=/mnt/project/Project_Plan_v6.md) - Detailed project plan

### Examples

  - [example\_request\_compile.json](https://www.google.com/search?q=examples/example_request_compile.json)
  - [example\_request\_query.json](https://www.google.com/search?q=examples/example_request_query.json)
  - [example\_response.json](https://www.google.com/search?q=examples/example_response.json)

-----

## ğŸ”— Related Projects

  - **[SIMPLE\_JSON](https://github.com/ljr1981/simple_json)** - High-level JSON library for Eiffel
  - **[EiffelStudio](https://www.eiffel.com/eiffelstudio/)** - The Eiffel IDE and compiler
  - **[Model Context Protocol](https://modelcontextprotocol.io/)** - AI-to-tool communication protocol
  - **[ECMA-367](https://www.ecma-international.org/publications-and-standards/standards/ecma-367/)** - Eiffel language standard

-----

## ğŸ“Š Success Metrics

### From SIMPLE\_JSON Experience (Validated)

  - **Core Library (1000+ LOC):** 1 hour (vs 40-80 traditional)
  - **JSON Schema (complex):** 2 hours (vs 80-120 traditional)
  - **Full Testing (100% coverage):** 1 hour (vs 40-60 traditional)
  - **Documentation:** 30 minutes (vs 20-30 hours traditional)

**Productivity Gain:** **44-66x faster** for well-specified work

### EifMate Goals

  - **Phase 0:** 8-12 hours (vs 40-80 traditional)
  - **Phase 1:** 4-8 hours (vs 80-120 traditional)
  - **Phase 2:** 3-6 hours (vs 40-60 traditional)
  - **Phase 3:** 4-8 hours (vs 60-80 traditional)

**Total Development:** 19-34 hours (vs 220+ traditional)  
**Calendar Time:** 7-8 weeks (includes dogfooding usage time)

-----

## ğŸ“œ License

MIT License

Copyright (c) 2024-2025 Larry Rix

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.

-----

## ğŸ“§ Contact & Support

**Author:** Larry Rix  
**GitHub:** [@ljr1981](https://github.com/ljr1981)  
**Project:** [github.com/ljr1981/eifmate](https://github.com/ljr1981/eifmate)

**Found a bug?** [Open an issue](https://github.com/ljr1981/eifmate/issues)  
**Have a feature request?** [Start a discussion](https://github.com/ljr1981/eifmate/discussions)  
**Want to contribute?** See [Contributing](https://www.google.com/search?q=%23-contributing) above

-----

## ğŸ™ Acknowledgments

  - **Claude Sonnet 4.5** - AI pair programming partner
  - **EiffelStudio Team** - For the excellent compiler and tools
  - **Eiffel Community** - For maintaining high standards
  - **Anthropic** - For Claude and MCP protocol

-----

**Status:** ğŸš§ Active Development - Phase 0 POC  
**Version:** 0.1.0 (Initial Structure)  
**Last Updated:** November 19, 2025

-----

*Built with â¤ï¸ using AI-assisted development. Dogfooding from Day 1.*
